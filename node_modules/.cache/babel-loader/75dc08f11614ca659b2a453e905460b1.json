{"ast":null,"code":"var _jsxFileName = \"D:\\\\Downloads\\\\talkblocks\\\\src\\\\StateContext.js\";\n// IMPORTS ////////////////////////////////////////////////////////////////////////////////////////////////\nimport React, { createContext, useEffect, useReducer, useState } from \"react\"; // Import Reducers\n\nimport gridReducer from \"./reducers/gridReducer\";\nimport talkyBlockyReducer from \"./reducers/talkyBlockyReducer\"; // Import helper functions\n\nimport { directions, colors, nonCommands } from \"./helpers/dictionary\"; // CREATE CONTEXT ////////////////////////////////////////////////////////////////////////////////////\n\nconst StateContext = createContext();\n\nfunction StateContextProvider(props) {\n  // STATE //////////////////////////////////////////////////////////////////////////////////////////\n  const [buildStage, setBuildStage] = useState(0);\n  const [keywords, setKeyWords] = useState([]);\n  const [talkyIsTalking, setTalkyIsTalking] = useState(false);\n  const [talkyBackground, setTalkyBackground] = useState(false);\n  const [grid, dispatchGrid] = useReducer(gridReducer, {});\n  const [talkyBlocky, dispatchTalkyBlocky] = useReducer(talkyBlockyReducer, {}); // SPEECH RECOGNITION //////////////////////////////////////////////////////////////////////\n\n  const dictionary = [];\n  let keywordsIndex = 0;\n  let recognition, synth, talkyBlockyVoice;\n  dictionary.push(...Object.keys(colors));\n  dictionary.push(...Object.keys(directions));\n  dictionary.push(...Object.keys(nonCommands)); // SPEECH RECOGNITION //////////////////////////////////////////////////////////////////////\n\n  function speechHandler(e) {\n    if (e.results[0].isFinal) {\n      const words = e.results[0][0].transcript.toLowerCase().split(\" \");\n      console.log(words);\n      const recognizedWords = words.filter(word => dictionary.includes(word));\n      keywords.push(...recognizedWords);\n      setKeyWords(keywords);\n      processNewKeywords();\n    }\n  }\n\n  function processNewKeywords() {\n    // see if there are new keywords to\n    if (keywordsIndex !== keywords.length) {\n      const newKeywords = keywords.slice(keywordsIndex, keywords.length);\n\n      if (newKeywords.length > 8) {\n        talkyBlockySpeak(\"You're lucky I'm a computer, because I would forget all of that otherwise.\");\n      }\n\n      newKeywords.forEach((keyword, index) => {\n        console.log(keyword);\n        setTimeout(keyword => {\n          if (directions.hasOwnProperty(keyword)) {\n            dispatchTalkyBlocky({\n              type: \"MOVE_TALKY_BLOCKY\",\n              grid: grid,\n              direction: directions[keyword]\n            });\n            setTalkyBackground(`wt${keyword}.png`);\n\n            if (newKeywords.length <= 8) {\n              talkyBlockySpeak([\"Walk walk walk\", \"\"], 0.25);\n            }\n          } else if (colors.hasOwnProperty(keyword)) {\n            dispatchGrid({\n              type: \"CHANGE_GRID_BLOCK_COLOR\",\n              position: [talkyBlocky.gridPos[0], talkyBlocky.gridPos[1]],\n              rgb: colors[keyword]\n            });\n\n            if (newKeywords.length <= 8) {\n              talkyBlockySpeak([`Poof. It's ${keyword}`, `Voila.`, `${keyword} it is.`], 0.25);\n            }\n          } else if (nonCommands.hasOwnProperty(keyword)) {\n            talkyBlockySpeak(nonCommands[keyword]);\n          }\n\n          setBuildStage(Date.now());\n        }, index * 350, keyword);\n        setTimeout(() => {\n          setTalkyBackground(`wtDefault.png`);\n        }, (newKeywords.length + 1) * 350);\n      });\n      keywordsIndex = keywords.length;\n    }\n  }\n\n  function talkyStartsListening() {\n    setTalkyBackground(\"wtListening.png\");\n  }\n\n  function talkyStopsListening() {\n    setTalkyBackground(false);\n  } // Some hacky shit to actually get the API to not stop when the speaker pauses.\n\n\n  function continuouslyTranscribe() {\n    recognition.start();\n  } // SPEECH SYNTHESIS //////////////////////////////////////////////////////////////////////\n\n\n  function talkyBlockySpeak(speech) {\n    let probability = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    if (Math.random() < probability) {\n      // see if multiple responses are possible\n      if (typeof speech === \"object\") {\n        speech = speech[Math.floor(Math.random() * speech.length)];\n      }\n\n      const utterThis = new SpeechSynthesisUtterance(speech);\n      utterThis.voice = talkyBlockyVoice;\n      utterThis.pitch = 1.5;\n      utterThis.rate = 0.75;\n      synth.speak(utterThis);\n      setTalkyIsTalking(true);\n      utterThis.addEventListener(\"end\", talkyStopsTalking);\n    }\n  }\n\n  function startTutorial(e) {\n    if (e.keyCode === 116) {\n      // 'T'\n      // talkyBlockyVoice.rate = 2\n      talkyBlockySpeak(\"Hi. I'm Talky Blocky! Hold down the spacebar to talk to me.\");\n      talkyBlockySpeak(\"If you say right, left, down or up I can move around the grid.\");\n      talkyBlockySpeak(\"Say the name of any color and I can change the grid blocks to that color!\");\n      talkyBlockySpeak(\"You can also say hello and thanks.\");\n      talkyBlockySpeak(\"Please speak clearly so that I can understand you.\");\n      talkyBlockySpeak(\"Press 'T' to hear the tutorial again.\");\n    }\n  }\n\n  function talkyStopsTalking() {\n    setTalkyIsTalking(false);\n  } // KEY EVENTS //////////////////////////////////////////////////////////////////////////////\n\n\n  function spaceBarDownHandler(e) {\n    if (e.keyCode === 32) {\n      try {\n        const sound = new Audio();\n        sound.src = \"/assets/sounds/listenSound.wav\";\n        sound.volume = 0.015;\n        sound.play();\n        recognition.start();\n        recognition.addEventListener(\"end\", continuouslyTranscribe);\n      } catch {// recognition already started\n      }\n    }\n  }\n\n  function spaceBarUpHandler(e) {\n    if (e.keyCode === 32) {\n      const sound = new Audio();\n      sound.src = \"/assets/sounds/executeSound.wav\";\n      sound.volume = 0.015;\n      sound.play();\n      recognition.removeEventListener(\"end\", continuouslyTranscribe);\n      recognition.stop();\n      document.addEventListener(\"keydown\", spaceBarDownHandler, {\n        once: true\n      });\n    }\n  } // Initialize //////////////////////////////////////////////////////////////////////////////////\n\n\n  useEffect(() => {\n    if (buildStage === 0) {\n      dispatchGrid({\n        type: \"BUILD_GRID\"\n      });\n      setBuildStage(1);\n    } else if (buildStage === 1) {\n      dispatchTalkyBlocky({\n        type: \"BUILD_TALKY_BLOCKY\",\n        grid: grid\n      });\n      setBuildStage(2);\n    } else if (buildStage === 2) {\n      document.addEventListener(\"keydown\", spaceBarDownHandler, {\n        once: true\n      });\n      document.addEventListener(\"keyup\", spaceBarUpHandler);\n      document.addEventListener(\"keypress\", startTutorial); // initializing the speech recognition API\n\n      recognition = new window.webkitSpeechRecognition();\n      recognition.continuous = false;\n      recognition.lang = \"en-US\";\n      recognition.interimResults = true;\n      recognition.maxAlternatives = 1;\n      recognition.addEventListener(\"result\", speechHandler);\n      recognition.addEventListener(\"audiostart\", talkyStartsListening);\n      recognition.addEventListener(\"audioend\", talkyStopsListening); // initializing the speech synthesis API\n\n      synth = window.speechSynthesis;\n      synth.addEventListener(\"voiceschanged\", () => {\n        const voices = synth.getVoices();\n        voices.forEach(voice => {\n          if (voice.name === \"Google US English\" && !talkyBlockyVoice) {\n            talkyBlockyVoice = voice;\n          }\n        });\n      }); // adding grammar so talky blocky understands certain words more clearly than others\n\n      const grammar = `#JSGF V1.0; grammar talkyblockyDictionary;  public <word> = ${dictionary.join(\" | \")};`;\n      const speechRecognitionList = new window.webkitSpeechGrammarList();\n      speechRecognitionList.addFromString(grammar, 1);\n      recognition.grammars = speechRecognitionList;\n      setBuildStage(3);\n    } else if (buildStage === 3) {\n      alert(\"Hi. I'm Talky Blocky! Hold down the spacebar to talk to me. If you say right, left, down or up I can move around the grid. Say the name of any color and I can change the grid blocks to that color! You can also say hello and thanks. Please speak clearly so that I can understand you. Press 'T' to hear me speak this to you.\");\n      setBuildStage(4);\n    }\n  }, [buildStage]); // PROVIDE CONTEXT //////////////////////////////////////////////////////////////////////////////\n\n  return /*#__PURE__*/React.createElement(StateContext.Provider, {\n    value: {\n      grid,\n      talkyBlocky,\n      talkyIsTalking,\n      talkyBackground\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 246,\n      columnNumber: 5\n    }\n  }, props.children);\n} // EXPORTS ///////////////////////////////////////////////////////////////////////////////////////\n\n\nexport default StateContext;\nexport { StateContextProvider };","map":{"version":3,"names":["React","createContext","useEffect","useReducer","useState","gridReducer","talkyBlockyReducer","directions","colors","nonCommands","StateContext","StateContextProvider","props","buildStage","setBuildStage","keywords","setKeyWords","talkyIsTalking","setTalkyIsTalking","talkyBackground","setTalkyBackground","grid","dispatchGrid","talkyBlocky","dispatchTalkyBlocky","dictionary","keywordsIndex","recognition","synth","talkyBlockyVoice","push","Object","keys","speechHandler","e","results","isFinal","words","transcript","toLowerCase","split","console","log","recognizedWords","filter","word","includes","processNewKeywords","length","newKeywords","slice","talkyBlockySpeak","forEach","keyword","index","setTimeout","hasOwnProperty","type","direction","position","gridPos","rgb","Date","now","talkyStartsListening","talkyStopsListening","continuouslyTranscribe","start","speech","probability","Math","random","floor","utterThis","SpeechSynthesisUtterance","voice","pitch","rate","speak","addEventListener","talkyStopsTalking","startTutorial","keyCode","spaceBarDownHandler","sound","Audio","src","volume","play","spaceBarUpHandler","removeEventListener","stop","document","once","window","webkitSpeechRecognition","continuous","lang","interimResults","maxAlternatives","speechSynthesis","voices","getVoices","name","grammar","join","speechRecognitionList","webkitSpeechGrammarList","addFromString","grammars","alert","children"],"sources":["D:/Downloads/talkblocks/src/StateContext.js"],"sourcesContent":["// IMPORTS ////////////////////////////////////////////////////////////////////////////////////////////////\nimport React, { createContext, useEffect, useReducer, useState } from \"react\";\n\n// Import Reducers\nimport gridReducer from \"./reducers/gridReducer\";\nimport talkyBlockyReducer from \"./reducers/talkyBlockyReducer\";\n\n// Import helper functions\nimport { directions, colors, nonCommands } from \"./helpers/dictionary\";\n\n// CREATE CONTEXT ////////////////////////////////////////////////////////////////////////////////////\nconst StateContext = createContext();\n\nfunction StateContextProvider(props) {\n  // STATE //////////////////////////////////////////////////////////////////////////////////////////\n  const [buildStage, setBuildStage] = useState(0);\n  const [keywords, setKeyWords] = useState([]);\n  const [talkyIsTalking, setTalkyIsTalking] = useState(false);\n  const [talkyBackground, setTalkyBackground] = useState(false);\n\n  const [grid, dispatchGrid] = useReducer(gridReducer, {});\n  const [talkyBlocky, dispatchTalkyBlocky] = useReducer(talkyBlockyReducer, {});\n\n  // SPEECH RECOGNITION //////////////////////////////////////////////////////////////////////\n  const dictionary = [];\n  let keywordsIndex = 0;\n  let recognition, synth, talkyBlockyVoice;\n\n  dictionary.push(...Object.keys(colors));\n  dictionary.push(...Object.keys(directions));\n  dictionary.push(...Object.keys(nonCommands));\n\n  // SPEECH RECOGNITION //////////////////////////////////////////////////////////////////////\n  function speechHandler(e) {\n    if (e.results[0].isFinal) {\n      const words = e.results[0][0].transcript.toLowerCase().split(\" \");\n      console.log(words);\n      const recognizedWords = words.filter(word => dictionary.includes(word));\n\n      keywords.push(...recognizedWords);\n      setKeyWords(keywords);\n      processNewKeywords();\n    }\n  }\n\n  function processNewKeywords() {\n    // see if there are new keywords to\n    if (keywordsIndex !== keywords.length) {\n      const newKeywords = keywords.slice(keywordsIndex, keywords.length);\n\n      if (newKeywords.length > 8) {\n        talkyBlockySpeak(\n          \"You're lucky I'm a computer, because I would forget all of that otherwise.\"\n        );\n      }\n\n      newKeywords.forEach((keyword, index) => {\n        console.log(keyword);\n\n        setTimeout(\n          keyword => {\n            if (directions.hasOwnProperty(keyword)) {\n              dispatchTalkyBlocky({\n                type: \"MOVE_TALKY_BLOCKY\",\n                grid: grid,\n                direction: directions[keyword]\n              });\n\n              setTalkyBackground(`wt${keyword}.png`);\n\n              if (newKeywords.length <= 8) {\n                talkyBlockySpeak([\"Walk walk walk\", \"\"], 0.25);\n              }\n            } else if (colors.hasOwnProperty(keyword)) {\n              dispatchGrid({\n                type: \"CHANGE_GRID_BLOCK_COLOR\",\n                position: [talkyBlocky.gridPos[0], talkyBlocky.gridPos[1]],\n                rgb: colors[keyword]\n              });\n\n              if (newKeywords.length <= 8) {\n                talkyBlockySpeak(\n                  [`Poof. It's ${keyword}`, `Voila.`, `${keyword} it is.`],\n                  0.25\n                );\n              }\n            } else if (nonCommands.hasOwnProperty(keyword)) {\n              talkyBlockySpeak(nonCommands[keyword]);\n            }\n\n            setBuildStage(Date.now());\n          },\n          index * 350,\n          keyword\n        );\n\n        setTimeout(() => {\n          setTalkyBackground(`wtDefault.png`);\n        }, (newKeywords.length + 1) * 350);\n      });\n\n      keywordsIndex = keywords.length;\n    }\n  }\n\n  function talkyStartsListening() {\n    setTalkyBackground(\"wtListening.png\");\n  }\n\n  function talkyStopsListening() {\n    setTalkyBackground(false);\n  }\n\n  // Some hacky shit to actually get the API to not stop when the speaker pauses.\n  function continuouslyTranscribe() {\n    recognition.start();\n  }\n\n  // SPEECH SYNTHESIS //////////////////////////////////////////////////////////////////////\n  function talkyBlockySpeak(speech, probability = 1) {\n    if (Math.random() < probability) {\n      // see if multiple responses are possible\n      if (typeof speech === \"object\") {\n        speech = speech[Math.floor(Math.random() * speech.length)];\n      }\n\n      const utterThis = new SpeechSynthesisUtterance(speech);\n      utterThis.voice = talkyBlockyVoice;\n      utterThis.pitch = 1.5;\n      utterThis.rate = 0.75;\n      synth.speak(utterThis);\n      setTalkyIsTalking(true);\n      utterThis.addEventListener(\"end\", talkyStopsTalking);\n    }\n  }\n\n  function startTutorial(e) {\n    if (e.keyCode === 116) {\n      // 'T'\n      // talkyBlockyVoice.rate = 2\n      talkyBlockySpeak(\n        \"Hi. I'm Talky Blocky! Hold down the spacebar to talk to me.\"\n      );\n      talkyBlockySpeak(\n        \"If you say right, left, down or up I can move around the grid.\"\n      );\n      talkyBlockySpeak(\n        \"Say the name of any color and I can change the grid blocks to that color!\"\n      );\n      talkyBlockySpeak(\"You can also say hello and thanks.\");\n      talkyBlockySpeak(\"Please speak clearly so that I can understand you.\");\n      talkyBlockySpeak(\"Press 'T' to hear the tutorial again.\");\n    }\n  }\n\n  function talkyStopsTalking() {\n    setTalkyIsTalking(false);\n  }\n\n  // KEY EVENTS //////////////////////////////////////////////////////////////////////////////\n  function spaceBarDownHandler(e) {\n    if (e.keyCode === 32) {\n      try {\n        const sound = new Audio();\n        sound.src = \"/assets/sounds/listenSound.wav\";\n        sound.volume = 0.015;\n        sound.play();\n\n        recognition.start();\n        recognition.addEventListener(\"end\", continuouslyTranscribe);\n      } catch {\n        // recognition already started\n      }\n    }\n  }\n\n  function spaceBarUpHandler(e) {\n    if (e.keyCode === 32) {\n      const sound = new Audio();\n      sound.src = \"/assets/sounds/executeSound.wav\";\n      sound.volume = 0.015;\n      sound.play();\n\n      recognition.removeEventListener(\"end\", continuouslyTranscribe);\n      recognition.stop();\n      document.addEventListener(\"keydown\", spaceBarDownHandler, { once: true });\n    }\n  }\n\n  // Initialize //////////////////////////////////////////////////////////////////////////////////\n  useEffect(() => {\n    if (buildStage === 0) {\n      dispatchGrid({ type: \"BUILD_GRID\" });\n      setBuildStage(1);\n    } else if (buildStage === 1) {\n      dispatchTalkyBlocky({ type: \"BUILD_TALKY_BLOCKY\", grid: grid });\n      setBuildStage(2);\n    } else if (buildStage === 2) {\n      document.addEventListener(\"keydown\", spaceBarDownHandler, { once: true });\n      document.addEventListener(\"keyup\", spaceBarUpHandler);\n      document.addEventListener(\"keypress\", startTutorial);\n\n      // initializing the speech recognition API\n      recognition = new window.webkitSpeechRecognition();\n      recognition.continuous = false;\n      recognition.lang = \"en-US\";\n      recognition.interimResults = true;\n      recognition.maxAlternatives = 1;\n\n      recognition.addEventListener(\"result\", speechHandler);\n      recognition.addEventListener(\"audiostart\", talkyStartsListening);\n      recognition.addEventListener(\"audioend\", talkyStopsListening);\n\n      // initializing the speech synthesis API\n      synth = window.speechSynthesis;\n\n      synth.addEventListener(\"voiceschanged\", () => {\n        const voices = synth.getVoices();\n        voices.forEach(voice => {\n          if (voice.name === \"Google US English\" && !talkyBlockyVoice) {\n            talkyBlockyVoice = voice;\n          }\n        });\n      });\n\n      // adding grammar so talky blocky understands certain words more clearly than others\n      const grammar = `#JSGF V1.0; grammar talkyblockyDictionary;  public <word> = ${dictionary.join(\n        \" | \"\n      )};`;\n\n      const speechRecognitionList = new window.webkitSpeechGrammarList();\n      speechRecognitionList.addFromString(grammar, 1);\n      recognition.grammars = speechRecognitionList;\n\n      setBuildStage(3);\n    } else if (buildStage === 3) {\n      alert(\n        \"Hi. I'm Talky Blocky! Hold down the spacebar to talk to me. If you say right, left, down or up I can move around the grid. Say the name of any color and I can change the grid blocks to that color! You can also say hello and thanks. Please speak clearly so that I can understand you. Press 'T' to hear me speak this to you.\"\n      );\n      setBuildStage(4);\n    }\n  }, [buildStage]);\n\n  // PROVIDE CONTEXT //////////////////////////////////////////////////////////////////////////////\n  return (\n    <StateContext.Provider\n      value={{ grid, talkyBlocky, talkyIsTalking, talkyBackground }}\n    >\n      {props.children}\n    </StateContext.Provider>\n  );\n}\n\n// EXPORTS ///////////////////////////////////////////////////////////////////////////////////////\nexport default StateContext;\nexport { StateContextProvider };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}